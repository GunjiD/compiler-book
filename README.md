# compiler-book
rui ueyama さんのオンラインブックの進捗

## 用語のメモ

### スタックポインタ

スタックはスタックの1番上のアドレスを保存する1つの変数のみを使って実装することができる。  
スタックトップを保持している記憶領域のことを __スタックポインタ__ という。  
x86-64 では関数を使ったプログラミングをサポートするために、スタックポインタ専用のレジスタと  
そのレジスタを利用する命令をサポートしている。  
スタックにデータを積むことを __プッシュ__ 、  
スタックに積まれたデータを取り出すことを __ポップ__  という。  

関数呼び出しの実例  

```
int plus(int x, int y) {
  return x + y;
}

int main() {
  return plus(3, 4);
}
main:
	mov rdi, 3
	mov rsi, 4
	call plus
	ret
```

上記のコードに対応するアセンブリ。  

アセンブラにおいては第一引数は RDI レジスタ  
第二引数は RSI レジスタに入れるという約束になっている  
call 命令が実行されると  

1. 次の命令のアドレスをスタックにプッシュ
2. call の引数として与えられたアドレスにジャンプ

```
.intel_syntax noprefix
.global plus, main

plus:

	add rsi, rdi
	mov rax, rsi
	ret
```

ret が行っていることは  

* スタックからアドレスを1つポップ
* そのアドレスにジャンプ

ret は call が行ったことを元に戻して、呼び出し元の関数の実行を再開する命令。  
このように call と ret は対になる命令として定義されている。  

上記の例では plus からリターンしたところにあるのは main の ret 命令。  
元の C コード では plus の返り値をそのまま main から返すということになっていた。  
ここでは plus の帰り値が RAX に入った状態になっているので、そのまま return することにより  
それをそのまま main からの返り値にすることができる。  


## ユニットテスト

テストコードを書くことにより、同じようなテストを手で毎回実行して確認をする作業を  
回避できる。  
ユニットテストというものは __自分の書いたコードを1発で動かして結果を機械的に比較できればよい__  


## トークナイザ（字句解析）

空白文字を読み飛ばす方法として、式を読む前に入力を単語に分割するという方法。  
日本語や英語と同じように算数の式やプログラミング言語も、単語の列から成り立つと考えることができる。  
例えば 5+20 は 5, +, 20, -, 4 という5つの単語でできていると考えることができる。  
この __単語__ を __token__ という。 token の間にある空白文字というのは token を区切るために  
存在しているだけで、単語を構成する一部分ではない。したがって文字列をトークン列に分割するときに  
空白文字を取り除くこのは自然なことである。文字列をトークン列に分割することを __tokenize する__ という。  
