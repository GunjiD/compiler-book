# compiler-book
rui ueyama さんのオンラインブックの進捗

## 用語のメモ

### スタックポインタ

スタックはスタックの1番上のアドレスを保存する1つの変数のみを使って実装することができる。  
スタックトップを保持している記憶領域のことを __スタックポインタ__ という。  
x86-64 では関数を使ったプログラミングをサポートするために、スタックポインタ専用のレジスタと  
そのレジスタを利用する命令をサポートしている。  
スタックにデータを積むことを __プッシュ__ 、  
スタックに積まれたデータを取り出すことを __ポップ__  という。  

関数呼び出しの実例  

```
int plus(int x, int y) {
  return x + y;
}

int main() {
  return plus(3, 4);
}
main:
	mov rdi, 3
	mov rsi, 4
	call plus
	ret
```

上記のコードに対応するアセンブリ。  

アセンブラにおいては第一引数は RDI レジスタ  
第二引数は RSI レジスタに入れるという約束になっている  
call 命令が実行されると  

1. 次の命令のアドレスをスタックにプッシュ
2. call の引数として与えられたアドレスにジャンプ

```
.intel_syntax noprefix
.global plus, main

plus:

	add rsi, rdi
	mov rax, rsi
	ret
```

ret が行っていることは  

* スタックからアドレスを1つポップ
* そのアドレスにジャンプ

ret は call が行ったことを元に戻して、呼び出し元の関数の実行を再開する命令。  
このように call と ret は対になる命令として定義されている。  

上記の例では plus からリターンしたところにあるのは main の ret 命令。  
元の C コード では plus の返り値をそのまま main から返すということになっていた。  
ここでは plus の帰り値が RAX に入った状態になっているので、そのまま return することにより  
それをそのまま main からの返り値にすることができる。  


## ユニットテスト

テストコードを書くことにより、同じようなテストを手で毎回実行して確認をする作業を  
回避できる。  

